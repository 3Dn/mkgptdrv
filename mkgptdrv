#!/bin/bash
####################################################################
# Copyright 2014 Donald A. Cupp Jr.
#
# This file is part of mkgptdrv.
#
# mkgptdrv is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
#
# mkgptdrv is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mkgptdrv. If not, see http://www.gnu.org/licenses/.
#####################################################################
#set -x

test $(id -u) -ne 0 && echo "please run as root" && exit 1

needed="sgdisk mkswap mkfs.vfat mkfs.ext4 fuser"
 
libutil="chain complex cptime display fancyhello hdt ifcpu \
	 keytest libmenu menu prdhcp pxechn rosh simple test \
	 test2 vesamenu"
	 
libcom32="chain cmd complex config display elf ethersel gfxboot \
	  gpxecmd hdt hexdump host ifcpu ifcpu64 ifmemdsk ifplop \
	  kbdmap kontron_wdt libmenu linux localboot lua mboot \
	  pcitest pmload prdhcp pxechn reboot rosh sanboot sdi \
	  simple sysdump test test2 vesamenu whichsys"
	  
libmenu="complex display hdt simple test test2"

libgpl="cpuidtest disk dmitest hdt ifcpu lua vpdtest zzjson"

liblua="lua"

usage()
{
	echo "
Usage:

This is a simple script to turn a block device into a gpt formated disk.
It does require that a unique name for your Project/Brand be passed with 
the -t <project> argument. This name will be used to set up the EFI loaders.

Additionally, you will need to tell it where it can find a syslinux theme.
This is passed as -c <directory with syslinux.cfg>. This file will be scanned for
the neceassary com32 files, and those files will be copied into the appropriate 
locations for each loader, along with the config folder.

Multiple partitions are supported, and can be added with -p <type:size:label>
The order they are entered will be used when creating the ID. At least one
partition will be made. By default, it will be an ESP partition that will
fill the disk and it will be labeled 'EFI System Partition'. At least one ESP
is required.

Sizes can be expressed as <size>B, K, M, G and S for sectors.

Options:
     --config,-c <dir>		   : Path to syslinux.cfg folder.
        --min,-m <size>		   : Minimum disk size allowed.
  --partition,-p <type:size:label> : Partition shorthand.
      --title,-t <Project/Brand>   : Will be used to label the EFI Loader Directory.
    --overlay,-o <dir>		   : Additional directory to merge in at the root level.
       --sync,-s		   : Mount volumes with sync enabled.
     --device,-d <block device>	   : The last argument is interpreted as the device anyways.
       --help,-h		   : Show this usage.

Partition Types:
         linux,l : Standard Ext4 Linux Volume
          home,h : Ext4 Linux Volume with gpt partition type set to home
          swap,s : Linux Swap Partition
          data,d : General Data Partition Formated Fat32
             LVM : Logical Volume Manager Partition
             ESP : EFI System Partition

Examples:
	mkgptpart -c /sys-themes/default -t 'MyProject' -o /build  /dev/loop0
	
	mkgptpart	-c /sys-themes/menu \\
			-t 'BobsDistro' \\
			-o /build \\
			-p ESP:1g:'EFI System Partition' \\
			-p s:2g \\
			-p l:0:System \\
			/dev/sdb

"
	if [ -n "$2" ]; then
		echo "$2"
	fi
	exit $1
}

getopts()
{
	part=0
	while [ -n "$1" ]; do
		case "$1" in
			-c|--config)	configdir="$2";	shift;;
			-m|--min)	min_size="$2";	shift;;
			-p|--partition)	add_part "$2";	shift; let part+=1;;
			-t|--title)	EFIname="$2";	shift;;
			-o|--overlay)	overlay="$2";	shift;;
			-d|--device)	device="$2";	shift;;
			-s|--sync)	mount_opts="-o sync";;
			--nvdefault)	nvdefault=true;;
			--msoft)	msoft=true;;
			-h|--help)	usage 255;;
			*) device="$1";;
		esac
		shift
	done
	let number_of_parts=$part-1
	if [ -z ${ID[0]} ]; then
		add_part "ESP:0:'EFI System Partition'"
		number_of_parts=0
	fi
}

get_dirs()
{
	for knownloc in /usr/share/syslinux /usr/lib/syslinux; do
		if [ -e $knownloc/bios/ifcpu64.c32 ]; then
			biosdir=$knownloc/bios
		elif [ -e $knownloc/ifcpu64.c32 ]; then
			biosdir=$knownloc
		fi
		if [ -e $knownloc/efi64/ifcpu64.c32 ]; then
			efi64dir=$knownloc/efi64
		fi
		if [ -e $knownloc/efi32/ifcpu64.c32 ]; then
			efi32dir=$knownloc/efi32
		fi
	done
	if [ -z "$configdir" ] || [ ! -e $configdir/syslinux.cfg ]; then
		usage 14 "You must specify and syslinux theme dir with a syslinux.cfg inside."
	fi
	if [ -z "$biosdir" ] || [ -z "$efi64dir" ] || [ -z "$efi32dir" ]; then
		usage 11 "We could not get a good read on your syslinux install."
	fi
	if [ -n "$overlay" ] && [ ! -e "$overlay" ]; then
		usage 15 "The requested root overlay directory $overlay, does not exist!"
	fi
	if [ ! -e `which extlinux` ]; then
		usage 12 "Could not find extlinux executable."
	fi
}

is_enabled()
{
	if [ -n "$1" ]; then
		for value in true on yes y 0; do
			if [ "$value" == "$1" ]; then
				return 0
			fi
		done
	fi
	return 1
}

scan_config()
{
	# Scan config file for potentially needed com32 files
	if [ -e $1 ]; then
		for com in \
			pmload vesamenu sdi cpuidtest dmitest whichsys vpdtest \
			elf cpuid debug linux vesainfo pxechn meminfo \
			pcitest ifplop ethersel liblua ifmemdsk kbdmap libcom32 \
			libmenu prdhcp gfxboot hexdump config libutil gpxecmd \
			kontron_wdt disk zzjson libgpl chain host rosh ifcpu \
			ifcpu64 hdt menu lua mboot cmd; do

			grep $1 -oe $com.c32 >> /tmp/syslinux-com32
		done
	else
		usage 13 "Could not find config $config."
	fi
}

com_deps()
{
	for lib in libutil libcom32 liblua libgpl libmenu; do
		if ! grep -qe $lib.c32 /tmp/syslinux-com32; then
			for module in `eval echo "\$"$lib`; do
				if grep -qe $module.c32 /tmp/syslinux-com32; then
					echo "$lib.c32" >> /tmp/syslinux-com32
					if [ "$lib" == "libmenu" ]; then
						echo libutil.c32 >> /tmp/syslinux-com32
						echo libcom32.c32 >> /tmp/syslinux-com32
					fi
				fi
			done
		fi
	done
	cat /tmp/syslinux-com32 |sort -u > /tmp/sorted
	rm /tmp/syslinux-com32
	mv /tmp/sorted /tmp/syslinux-com32
}

copy_files()
{
	ESP=/tmp/syslinux-mount
	BIOSDIR=$ESP/boot/syslinux
	EFI32=$ESP/EFI/"$EFIname"/efi32
	EFI64=$ESP/EFI/"$EFIname"/efi64
	MSDIR=$ESP/EFI/Microsoft/Boot
	NVDIR=$ESP/EFI/BOOT
	mkdir -p "$BIOSDIR"
	mkdir -p "$EFI32"
	mkdir -p "$EFI64"
	echo -e "\nCopying Syslinux Theme"
	copy_dir "$configdir"		"$BIOSDIR"
	copy_dir "$configdir"		"$EFI32"
	copy_dir "$configdir"		"$EFI64"
	if is_enabled $nvdefault; then
		copy_dir "$configdir"	"$NVDIR"
	fi
	if is_enabled $msoft; then
		copy_dir "$configdir" 	"$MSDIR"
	fi
	for com in `cat /tmp/syslinux-com32`; do
		echo -e "\nCopying com32 files"
		copy_file "$biosdir/$com"	"$BIOSDIR/$com"
		copy_file "$efi32dir/$com"	"$EFI32/$com"
		copy_file "$efi64dir/$com"	"$EFI64/$com"
		if is_enabled $nvdefault; then
			copy_file "$efi64dir/$com" "$NVDIR/$com"
		fi
		if is_enabled $msoft; then
			copy_file "$efi64dir/$com" "$MSDIR/$com"
		fi
	done
	echo -e "\nCopying EFI loaders"
	copy_file "$efi32dir/syslinux.efi"	"$EFI32/syslinux.efi"
	copy_file "$efi32dir/ldlinux.e32" 	"$EFI32/ldlinux.e32"
	copy_file "$efi64dir/syslinux.efi"	"$EFI64/syslinux.efi"
	copy_file "$efi64dir/ldlinux.e64"	"$EFI64/ldlinux.e64"
	if is_enabled $nvdefault; then
		copy_file "$efi64dir/syslinux.efi" "$NVDIR/bootx64.efi"
		copy_file "$efi64dir/ldlinux.e64"  "$NVDIR/ldlinux.e64"
	fi
	if is_enabled $msoft; then
		copy_file "$efi64dir/syslinux.efi" "$MSDIR/bootmgfw.efi"
		copy_file "$efi64dir/ldlinux.e64"  "$MSDIR/ldlinux.e64"
	fi
	echo -e "\nCopying in the Overlay Directory"
	if [ -n "$overlay" ]; then
		copy_dir "$overlay"	"$ESP"
	fi
}

efi_ready()
{
	if [ -z "$EFIname" ]; then
		usage 9 "You must specify the name of 'Your' EFI bootloader."
	fi
	if [ -z "$ESPpart" ]; then
		usage 10 "You must have at least one ESP partition."
	fi
	return 0
}

block_device()
{
	if [ -n "$1" ] && \
	   [ -e /sys/block/`basename "$1"`/dev ]; then
		return 0
	else
		usage 1 "No block device specified, or not a block device."
	fi
}

not_being_used()
{
	for mount in `list_mounts "$1"`; do
		if [ -n "`fuser -m $mount`" ]; then
			usage 2 "Device $1 is still in use."
		fi
	done
	return 0
}

user_agrees()
{
	while [ -z "$REPLY" ]; do
		echo "All data on the selected device is about to be overwritten!"
		echo "Are you sure you want to do this?"
		read -n 1 -r
		if   [[ "$REPLY" =~ ^[Yy]$ ]]; then
			echo ""
			return 0
		elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
			exit 3
		else
			echo -e "\nInvalid response. $REPLY\n"
			unset REPLY
		fi
	done
}

add_part()
{
	oIFS=$IFS
	IFS='\n'
	let ID[$part]=$part+1 
	if [ "${ID[$part]}" == "128" ]; then
		echo "Really, you need that many partitions?"
		exit 5150
	fi
	# linux home swap data ESP
	type[$part]=`echo "$1" |cut -d':' -f1`
	if echo $1 | grep -qe ":"; then
		size[$part]=`echo "$1" |cut -d':' -f2`
		label[$part]=`echo "$1" |cut -d':' -f3`
	fi
	if [ -z "${size[$part]}" ]; then
		size[$part]=0
	fi
	case ${type[$part]} in
		l|linux) type[$part]=8300;;
		s|swap)	type[$part]=8200;;
		h|home) type[$part]=8302;;
		d|data) type[$part]=0700;;
		LVM)	type[$part]=8e00;;
		ESP)	type[$part]=ef00
			if [ -n "$ESPpart" ]; then
				usage 12 "You can only have one ESP partition."
			else
				ESPpart=${ID[$part]}
			fi
		;;
	esac
	IFS=$oIFS
}

convert_to_sectors()
{
	local size
	local unit
	unit="`echo $1 |sed -e s/[0-9]//g`"
	if [ -n "$unit" ]; then
		unit=`echo $unit |tr [a-z] [A-Z]`
		value=${1%?}
	else
		unit=B
		value=$1
	fi
	case $unit in
		B)	let "size=${value}/512";;
		S)	let "size=${value}";;
		K)	let "size=${value}*2";;
		M)	let "size=${value}*2*1024";;
		G)	let "size=${value}*2*1024*1024";;
		*)	echo "Invalid Unit $unit"; usage 5;;
	esac
	echo $size
}

enough_room()
{
	disk_size=`blockdev --getsz $device`
	let last_psec=$disk_size-32
	let last_psec=$last_psec/2048*2048
	let last_psec-=1
	if [ -n "$min_size" ]; then
		min_size=`convert_to_sectors $min_size`
		if [ "$last_psec" -lt "$min_size" ]; then
			usage 7 "Disk is less than the requested size!"
		fi
	fi
	total=2048
	for part in `seq 0 $number_of_parts`; do
		if [ "$total" == "$last_psec" ]; then
			usage 8 "Only one partition can be expanded to fill the disk, and it must be the last one."
		fi
		start[$part]=$total
		if [ -n "${size[$part]}" ] && [ "${size[$part]}" != "0" ]; then
			size[$part]=`convert_to_sectors ${size[$part]}`
			let end[$part]=${start[$part]}+${size[$part]}-1
			let total+=${size[$part]}
		else
			end[$part]=$last_psec
			total=$last_psec
			let size[$part]=$last_psec-${start[$part]}+1
		fi
	done
	if [ "$total" -le "$last_psec" ]; then
		return 0
	else
		usage 6 "There is not enough room on the disk for all the requested partitions!"
	fi
}

install_mbr()
{
	echo -e "Installing Bootsector"
	dd if=$biosdir/gptmbr.bin of=$device bs=440 count=1 conv=notrunc
}

part_id()
{
	short_dev=`basename $device`
	if grep -qoe "$short_dev[p][0-9]*" /proc/partitions; then
		p=p
	fi
}

mount_dev()
{
	mount ${mount_opts} ${device}${p}${ESPpart} /tmp/syslinux-mount
}

main()
{
	efi_ready
	get_dirs
	# Any text file is a potential config, and there are plenty of ways to get one in there,
	# so lets look at all of them in the config folder.
	for file in `find $configdir -type f`;do 
		if file $file |grep -qe 'ASCII text'; then
			scan_config $file
		fi
	done
	com_deps
	if block_device $device && \
	   not_being_used $device && \
	   enough_room $device && \
	   user_agrees; then
		partition
		format
		install_mbr
		mkdir -p /tmp/syslinux-mount
		mount_dev
		sync
		copy_files
		_sync
		echo -e "\nInstalling Bios Bootloader"
		extlinux -i $BIOSDIR
		sync
		umount /tmp/syslinux-mount
		rmdir /tmp/syslinux-mount
		rm  /tmp/syslinux-com32
	fi
}

buffer_size()
{
	local dirty=`grep -e Dirty: /proc/meminfo |grep -oe "[0-9]*"`
	local writeback=`grep -e Writeback: /proc/meminfo |grep -oe "[0-9]*"`
	let buffer=$dirty+$writeback
	echo $buffer
}

_sync()
{
	echo -e "\nSyncronizing the disk"
	format='\rProgress %3s at %6s Per Second'
	freq=2
	counter=0
	let max=`buffer_size`
	last=$max
	sync &
	spid=$!
	while ps -p $spid >/dev/null 2>&1; do
		now=`buffer_size`
		let persec=$last-$now
		let persec=$persec/$freq
		let progress=$max-$now
		let pct=100*$progress/$max
		printf "$format" "${pct}%" "${persec}K"
		last=$now
		sleep $freq
		let counter+=1
	done
	let time=$counter*$freq
	let persec=$max/$time
	printf "$format\n" "100%" "${persec}K"
}

check_needed()
{
	for command in $needed; do
		if ! which $command >/dev/null 2>&1; then
			still_need="$still_need $command"
		fi
	done
	if [ -n "$still_need" ]; then
		echo "We needed the following commands but were unable to locate them."
		echo "$still_need"
		exit 20
	fi
}

list_mounts()
{
	grep -oe "$1[0-9]*" /proc/mounts
}

orbail()
{
	if [ $? -gt 0 ]; then 
		if [ -n "$2" ]; then
			echo "$2" 
		else
			echo "Something went very wrong?"
		fi
		exit $1
	else
		return 0
	fi
}

partition()
{
	part_id
	for mount in `list_mounts ${device}${p}`; do
		umount -f $mount; orbail 29
	done
	dd if=/dev/zero of=$device bs=1M count=2; orbail 16
	dd if=/dev/zero of=$device bs=512 count=32 seek=$(($disk_size - 32)); orbail 17
	blockdev --rereadpt $device; orbail 18
	sgdisk -o $device; orbail 19
	echo -e "\nCreating Partitions"
	printf "%3s %4s %12s %-40s\n" ID Type MBytes Label
	echo "==================================================="
	for part in `seq 0 $number_of_parts`; do
		let msize=${size[$part]}/2048
		printf "%3s %4s %12s %-40s\n" "${ID[$part]}" "${type[$part]}" "$msize" "${label[$part]}"
		if [ -n "${label[$part]}" ]; then
			sgdisk	-n ${ID[$part]}:${start[$part]}:${end[$part]} \
					-t ${ID[$part]}:${type[$part]} \
					-c ${ID[$part]}:"${label[$part]}" \
					$device 1>/dev/null; orbail 20
		else
			sgdisk	-n ${ID[$part]}:${start[$part]}:${end[$part]} \
					-t ${ID[$part]}:${type[$part]} \
					$device 1>/dev/null; orbail 21
		fi
	done
	sgdisk $device --attributes=1:set:2 1>/dev/null; orbail 22
}

format()
{
	part_id
	echo -e "\nFormating Partitions"
	for part in `seq 0 $number_of_parts`; do
		case ${type[$part]} in
			0700|ef00)
				if [ -n "${label[$part]}" ]; then
					mkfs.vfat ${device}${p}${ID[$part]} -n "${label[$part]}"; orbail 23
				else
					mkfs.vfat ${device}${p}${ID[$part]}; orbail 24
				fi
			;;
			8300|8302)
				if [ -n "${label[$part]}" ]; then
					mkfs.ext4 ${device}${p}${ID[$part]} -L "${label[$part]}"; orbail 25
				else
					mkfs.ext4 ${device}${p}${ID[$part]}; orbail 26
				fi
			;;
			8200)
				if [ -n "${label[$part]}" ]; then
					mkswap ${device}${p}${ID[$part]} -L "${label[$part]}"; orbail 27
				else
					mkswap ${device}${p}${ID[$part]}; orbail 28
				fi
			;;
			8e00) #pvcreate ${device}${p}${ID[$part]}
				echo "LVM Partitioned, the rest is up to you"
			;;
		esac
	done
}

copy_dir()
{
	dir=$1
	if [ "`echo $dir | rev | cut -c1`" == "/" ]; then
		dir="`echo $dir| rev | cut -c2- | rev`"
	fi
	for adir in `find "$dir" -type d | sed -e s:^"$dir"::g |cut -c2-`; do
		mkdir -p "$2/$adir"
	done
	for file in `find "$dir" -type f| sed -e s:^"$dir"/::g`; do
		copy_file "$dir/$file" "$2/$file"
	done
}

copy_file()
{
	cp -f "$1" "$2" &
	cppid=$!

	orig_size=`stat -c %s "$1"`
	dest_size=0
	timeout=0
	format='Copying %-15s to %-50s %-3s Complete\r'
	if [ -n "$mount_opts" ]; then
		freq='1'
	else
		freq='.1'
	fi
	while ps -p $cppid >/dev/null 2>&1 && [ $timeout -lt 30 ]; do
		if [ -e "$2" ]; then
			dest_size=`stat -c %s "$2"`
		else
			let timeout+=1
		fi
		let pct=100*$dest_size/$orig_size
		printf "$format" "`basename $1`" "`dirname $2`" "${pct}%"
		sleep $freq
	done
	if [ `stat -c %s "$2"` -eq $orig_size ]; then
		printf "$format" "`basename $1`" "`dirname $2`" "100%"
	else
		echo "Something went wrong with the copy!"
		kill -KILL $cppid
	fi
	echo ""
}

check_needed
getopts "$@"
main

exit 0
