#!/bin/bash
####################################################################
# Copyright 2014 Donald A. Cupp Jr.
#
# This file is part of mkgptdrv.
#
# mkgptdrv is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
#
# mkgptdrv is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mkgptdrv. If not, see http://www.gnu.org/licenses/.
#####################################################################
#set -x
test $(id -u) -ne 0 && echo "please run as root" && exit 1

libutil="chain complex cptime display fancyhello hdt ifcpu \
	 keytest libmenu menu prdhcp pxechn rosh simple test \
	 test2 vesamenu"
libcom32="chain cmd complex config display elf ethersel gfxboot \
	  gpxecmd hdt hexdump host ifcpu ifcpu64 ifmemdsk ifplop \
	  kbdmap kontron_wdt libmenu linux localboot lua mboot \
	  pcitest pmload prdhcp pxechn reboot rosh sanboot sdi \
	  simple sysdump test test2 vesamenu whichsys"
libmenu="complex display hdt simple test test2"
libgpl="cpuidtest disk dmitest hdt ifcpu lua vpdtest zzjson"
liblua="lua"

getopts()
{
	part=0
	while [ -n "$1" ]; do
		case "$1" in
			-c|--config)	configdir="$2";	shift;;
			-m|--min)	min_size="$2";	shift;;
			-p|--partition)	add_part "$2";	shift; let part+=1;;
			-t|--title)	EFIname="$2";	shift;;
			-s|--sync)	mount_opts="-o sync";;
			--nvdefault)	nvdefault=true;;
			--msoft)	msoft=true;;
			*) device="$1";;
		esac
		shift
	done
	let number_of_parts=$part-1
}

get_dirs()
{
	for knownloc in /usr/share/syslinux /usr/lib/syslinux; do
		if [ -e $knownloc/bios/ifcpu64.c32 ]; then
			biosdir=$knownloc/bios
		elif [ -e $knownloc/ifcpu64.c32 ]; then
			biosdir=$knownloc
		fi
		if [ -e $knownloc/efi64/ifcpu64.c32 ]; then
			efi64dir=$knownloc/efi64
		fi
		if [ -e $knownloc/efi32/ifcpu64.c32 ]; then
			efi32dir=$knownloc/efi32
		fi
	done
	if [ -z "$configdir" ] || [ ! -e $configdir/syslinux.cfg ]; then
		echo "You must specify and syslinux theme dir with a syslinux.cfg inside."
		exit 14
	fi
	if [ -z "$biosdir" ] || [ -z "$efi64dir" ] || [ -z "$efi32dir" ]; then
		echo "We could not get a good read on your syslinux install."
		exit 11
	fi
	if [ ! -e `which extlinux` ]; then
		echo "Could not find extlinux executable."
		exit 12
	fi
}

is_enabled()
{
	if [ -n "$1" ]; then
		for value in true on yes y 0; do
			if [ "$value" == "$1" ]; then
				return 0
			fi
		done
	fi
	return 1
}

scan_config()
{
	# Scan config file for potentially needed com32 files
	if [ -e $1 ]; then
		for com in \
			pmload vesamenu sdi cpuidtest dmitest whichsys vpdtest \
			elf cpuid debug linux vesainfo pxechn meminfo \
			pcitest ifplop ethersel liblua ifmemdsk kbdmap libcom32 \
			libmenu prdhcp gfxboot hexdump config libutil gpxecmd \
			kontron_wdt disk zzjson libgpl chain host rosh ifcpu \
			ifcpu64 hdt menu lua mboot cmd; do

			grep $1 -oe $com.c32 >> /tmp/syslinux-com32
		done
	else
		echo "Could not find config $config."
		exit 13
	fi
}

com_deps()
{
	for lib in libutil libcom32 liblua libgpl libmenu; do
		if ! grep -qe $lib.c32 /tmp/syslinux-com32; then
			for module in `eval echo "\$"$lib`; do
				if grep -qe $module.c32 /tmp/syslinux-com32; then
					echo "$lib.c32" >> /tmp/syslinux-com32
					if [ "$lib" == "libmenu" ]; then
						echo libutil.c32 >> /tmp/syslinux-com32
						echo libcom32.c32 >> /tmp/syslinux-com32
					fi
				fi
			done
		fi
	done
	cat /tmp/syslinux-com32 |sort -u > /tmp/sorted
	rm /tmp/syslinux-com32
	mv /tmp/sorted /tmp/syslinux-com32
}

copy_files()
{
	ESP=/tmp/syslinux-mount
	BIOSDIR=$ESP/boot/syslinux
	EFI32=$ESP/EFI/"$EFIname"/efi32
	EFI64=$ESP/EFI/"$EFIname"/efi64
	MSDIR=$ESP/EFI/Microsoft/Boot
	NVDIR=$ESP/EFI/BOOT
	echo -e "\nCopying Syslinux Theme"
	copy_dir "$configdir"		"$BIOSDIR"
	copy_dir "$configdir"		"$EFI32"
	copy_dir "$configdir"		"$EFI64"
	if is_enabled $nvdefault; then
		copy_dir "$configdir"	"$NVDIR"
	fi
	if is_enabled $msoft; then
		copy_dir "$configdir" 	"$MSDIR"
	fi
	for com in `cat /tmp/syslinux-com32`; do
		echo -e "\nCopying com32 files"
		copy_file "$biosdir/$com"	"$BIOSDIR/$com"
		copy_file "$efi32dir/$com"	"$EFI32/$com"
		copy_file "$efi64dir/$com"	"$EFI64/$com"
		if is_enabled $nvdefault; then
			copy_file "$efi64dir/$com" "$NVDIR/$com"
		fi
		if is_enabled $msoft; then
			copy_file "$efi64dir/$com" "$MSDIR/$com"
		fi
	done
	echo -e "\nCopying EFI loaders"
	copy_file "$efi32dir/syslinux.efi"	"$EFI32/syslinux.efi"
	copy_file "$efi32dir/ldlinux.e32" 	"$EFI32/ldlinux.e32"
	copy_file "$efi64dir/syslinux.efi"	"$EFI64/syslinux.efi"
	copy_file "$efi64dir/ldlinux.e64"	"$EFI64/ldlinux.e64"
	if is_enabled $nvdefault; then
		copy_file "$efi64dir/syslinux.efi" "$NVDIR/bootx64.efi"
		copy_file "$efi64dir/ldlinux.e64"  "$NVDIR/ldlinux.e64"
	fi
	if is_enabled $msoft; then
		copy_file "$efi64dir/syslinux.efi" "$MSDIR/bootmgfw.efi"
		copy_file "$efi64dir/ldlinux.e64"  "$MSDIR/ldlinux.e64"
	fi
}

efi_ready()
{
	if [ -z "$EFIname" ]; then
		echo "You must specify the name of \"Your\" EFI bootloader"
		exit 9
	fi
	if [ -z "$ESPpart" ]; then
		echo "You must have at least one ESP partition"
		exit 10
	fi
	return 0
}

block_device()
{
	if [ -n "$1" ] && \
	   [ -e /sys/block/`basename "$1"`/dev ]; then
		return 0
	else
		echo "No block device specified, or not a block device."
		exit 1
	fi
}

not_being_used()
{
	for mount in `list_mounts "$1"`; do
		if [ -n "`fuser -m $mount`" ]; then
			echo "Device $1 is still in use"
			exit 2
		fi
	done
	return 0
}

user_agrees()
{
	while [ -z "$REPLY" ]; do
		echo "All data on the selected device is about to be overwritten!"
		echo "Are you sure you want to do this?"
		read -n 1 -r
		if   [[ "$REPLY" =~ ^[Yy]$ ]]; then
			echo ""
			return 0
		elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
			exit 3
		else
			echo -e "\nInvalid response $REPLY\n"
			unset REPLY
		fi
	done
}

add_part()
{
	oIFS=$IFS
	IFS='\n'
	let ID[$part]=$part+1 
	if [ "${ID[$part]}" == "128" ]; then
		echo "Really, you need that many partitions?"
		exit 5150
	fi
	# linux home swap data ESP
	type[$part]=`echo "$1" |cut -d':' -f1`
	if echo $1 | grep -qe ":"; then
		size[$part]=`echo "$1" |cut -d':' -f2`
		label[$part]=`echo "$1" |cut -d':' -f3`
	fi
	if [ -z "${size[$part]}" ]; then
		size[$part]=0
	fi
	case ${type[$part]} in
		l|linux) type[$part]=8300;;
		s|swap)	type[$part]=8200;;
		h|home) type[$part]=8302;;
		d|data) type[$part]=0700;;
		LVM)	type[$part]=8e00;;
		ESP)	type[$part]=ef00
			if [ -n "$ESPpart" ]; then
				echo "You can only have one ESP partition"
				exit 12
			else
				ESPpart=${ID[$part]}
			fi
		;;
	esac
	IFS=$oIFS
}

convert_to_sectors()
{
	local size
	local unit
	unit="`echo $1 |sed -e s/[0-9]//g`"
	if [ -n "$unit" ]; then
		unit=`echo $unit |tr [a-z] [A-Z]`
		value=${1%?}
	else
		unit=B
		value=$1
	fi
	case $unit in
		B)	let "size=${value}/512";;
		S)	let "size=${value}";;
		K)	let "size=${value}*2";;
		M)	let "size=${value}*2*1024";;
		G)	let "size=${value}*2*1024*1024";;
		*)	echo "Invalid Unit $unit"; exit 5;;
	esac
	echo $size
}

enough_room()
{
	disk_size=`blockdev --getsz $device`
	let last_psec=$disk_size-32
	let last_psec=$last_psec/2048*2048
	let last_psec-=1
	if [ -n "$min_size" ]; then
		min_size=`convert_to_sectors $min_size`
		if [ "$last_psec" -lt "$min_size" ]; then
			echo "Disk is less than the requested size!"
			exit 7
		fi
	fi
	total=2048
	for part in `seq 0 $number_of_parts`; do
		if [ "$total" == "$last_psec" ]; then
			echo "Only one partition can be expanded to fill the disk,"
			echo "and it must be the last one."
			exit 8
		fi
		start[$part]=$total
		if [ -n "${size[$part]}" ] && [ "${size[$part]}" != "0" ]; then
			size[$part]=`convert_to_sectors ${size[$part]}`
			let end[$part]=${start[$part]}+${size[$part]}-1
			let total+=${size[$part]}
		else
			end[$part]=$last_psec
			total=$last_psec
		fi
	done
	if [ "$total" -le "$last_psec" ]; then
		return 0
	else
		echo "There is not enough room on the disk for all the requested partitions!"
		exit 6
	fi
}

install_mbr()
{
	echo -e "Installing Bootsector"
	dd if=$biosdir/gptmbr.bin of=$device bs=440 count=1 conv=notrunc
}

main()
{
	efi_ready
	get_dirs
	# Any text file is a potential config, and there are plenty of ways to get one in there,
	# so lets look at all of them in the config folder.
	for file in `find $configdir -type f`;do 
		if file $file |grep -qe 'ASCII text'; then
			scan_config $file
		fi
	done
	com_deps
	if block_device $device && \
	   not_being_used $device && \
	   enough_room $device && \
	   user_agrees; then
		partition
		format
		install_mbr
		mkdir -p /tmp/syslinux-mount
		mount ${mount_opts} ${device}$ESPpart /tmp/syslinux-mount
		copy_files
		_sync
		echo -e "\nInstalling Bios Bootloader"
		extlinux -i $BIOSDIR
		umount /tmp/syslinux-mount
		rmdir /tmp/syslinux-mount
		rm  /tmp/syslinux-com32
	fi
}

buffer_size()
{
	local dirty=`grep -e Dirty: /proc/meminfo |grep -oe "[0-9]*"`
	local writeback=`grep -e Writeback: /proc/meminfo |grep -oe "[0-9]*"`
	let buffer=$dirty+$writeback
	echo $buffer
}

_sync()
{
	echo -e "\nSyncronizing the disk"
	freq=2
	let max=`buffer_size`
	last=$max
	sync &
	while pidof sync 2>&1>/dev/null; do
		now=`buffer_size`
		let persec=$last-$now
		let persec=$persec/$freq
		let progress=$max-$now
		let pct=100*$progress/$max
		printf "Progress %3s at %6s Per Second\r"  "${pct}%"  "${persec}K"
		last=$now
		sleep $freq
	done
	echo ""
}

list_mounts()
{
	cat /proc/mounts |grep -oe "$1[0-9]*"
}

partition()
{
	for mount in `list_mounts $device`; do
		umount -f $mount
	done
	dd if=/dev/zero of=$device bs=1M count=2
	dd if=/dev/zero of=$device bs=512 count=32 seek=$(($disk_size - 32))
	blockdev --rereadpt $device
	sgdisk -o $device
	echo -e "\nCreating Partitions"
	printf "%3s %4s %12s %-40s\n" ID Type Size Label
	echo "==================================================="
	for part in `seq 0 $number_of_parts`; do
		printf "%3s %4s %12s %-40s\n" "${ID[$part]}" "${type[$part]}" "${size[$part]}" "${label[$part]}"
		if [ -n "${label[$part]}" ]; then
			sgdisk	-n ${ID[$part]}:${start[$part]}:${end[$part]} \
					-t ${ID[$part]}:${type[$part]} \
					-c ${ID[$part]}:"${label[$part]}" \
					$device 1> /dev/null
		else
			sgdisk	-n ${ID[$part]}:${start[$part]}:${end[$part]} \
					-t ${ID[$part]}:${type[$part]} \
					$device 1> /dev/null
		fi
	done
	sgdisk $device --attributes=1:set:2 1> /dev/null
}

format()
{
	echo -e "\nFormating Partitions"
	for part in `seq 0 $number_of_parts`; do
		case ${type[$part]} in
			0700|ef00)
				if [ -n "${label[$part]}" ]; then
					mkfs.vfat ${device}${ID[$part]} -n "${label[$part]}"
				else
					mkfs.vfat ${device}${ID[$part]}
				fi
			;;
			8300|8302)
				if [ -n "${label[$part]}" ]; then
					mkfs.ext4 ${device}${ID[$part]} -L "${label[$part]}"
				else
					mkfs.ext4 ${device}${ID[$part]}
				fi
			;;
			8200)
				if [ -n "${label[$part]}" ]; then
					mkswap ${device}${ID[$part]} -L "${label[$part]}"
				else
					mkswap ${device}${ID[$part]}
				fi
			;;
			8e00) pvcreate ${device}${ID[$part]}
			;;
		esac
	done
}

copy_dir()
{
	for dir in `find "$1" -type d | sed -e s:^"$1"::g |cut -c2-`; do
		mkdir -p "$2/$dir"
	done
	for file in `find "$1" -type f| sed -e s:^"$1"/::g`; do
		copy_file "$1/$file" "$2/$file"
	done
}

copy_file()
{
	cp -f "$1" "$2" &

	orig_size=`stat -c %s "$1"`
	dest_size=0
	output=false
	while [ $orig_size -gt $dest_size ]; do
		if [ -e "$2" ]; then
			dest_size=`stat -c %s "$2"`
		fi
		let pct=100*$dest_size/$orig_size
		printf "Copying %-15s to %-50s %-3s Complete\r" "`basename $1`" "`dirname $2`" "${pct}%"
		sleep .1
		output=true
	done
	if is_enabled $output; then
		echo ""
	fi
}

getopts "$@"
main

exit 0
