#!/bin/bash
####################################################################
# Copyright 2014 Donald A. Cupp Jr.
#
# This file is part of mkgptdrv.
#
# mkgptdrv is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
#
# mkgptdrv is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mkgptdrv. If not, see http://www.gnu.org/licenses/.
#####################################################################
#set -x

test $(id -u) -ne 0 && echo "please run as root" && exit 1

libutil="chain complex cptime display fancyhello hdt ifcpu \
	 keytest libmenu menu prdhcp pxechn rosh simple test \
	 test2 vesamenu"
libcom32="chain cmd complex config display elf ethersel gfxboot \
	  gpxecmd hdt hexdump host ifcpu ifcpu64 ifmemdsk ifplop \
	  kbdmap kontron_wdt libmenu linux localboot lua mboot \
	  pcitest pmload prdhcp pxechn reboot rosh sanboot sdi \
	  simple sysdump test test2 vesamenu whichsys"
libmenu="complex display hdt simple test test2"
libgpl="cpuidtest disk dmitest hdt ifcpu lua vpdtest zzjson"
liblua="lua"

usage()
{
	echo "
Usage:

This is a simple script to turn a block device into a gpt formated disk.
It does require that a unique name for your Project/Brand be passed with 
the -t <project> argument. This name will be used to set up the EFI loaders.

Additionally, you will need to tell it where it can find a syslinux theme.
This is passed as -c <directory with syslinux.cfg>. This file will be scanned for
the neceassary com32 files, and those files will be copied into the appropriate 
locations for each loader, along with the config folder.

Multiple partitions are supported, and can be added with -p <type:size:label>
The order they are entered will be used when creating the ID. At least the type is
required if only one partition is going to be made, and it must be ESP.
The size will be guessed to fill the disk and the label will be blank.

Sizes can be expressed as <size>B, K, M, G and S for sectors.

Options:
     --config,-c <dir>		   : Path to syslinux.cfg folder.
        --min,-m <size>		   : Minimum disk size allowed.
  --partition,-p <type:size:label> : Partition shorthand.
      --title,-t <Project/Brand>   : Will be used to label the EFI Loader Directory.
    --overlay,-o <dir>		   : Additional directory to merge in at the root level.
       --sync,-s		   : Mount volumes with sync enabled.
     --device,-d <block device>	   : The last argument is interpreted as the device anyways.
       --help,-h		   : Show this usage.

Partition Types:
         linux,l : Standard Ext4 Linux Volume
          home,h : Ext4 Linux Volume Labeled home
          swap,s : Linux Swap Partition
          data,d : General Data Partition Formated Fat32
             LVM : Logical Volume Manager Partition
             ESP : EFI System Partition

Example:
	mkgptpart -c /sys-themes/default -t 'MyProject' -o /build -p ESP /dev/loop0

"
	if [ -n "$2" ]; then
		echo "$2"
	fi
	exit $1
}

getopts()
{
	part=0
	while [ -n "$1" ]; do
		case "$1" in
			-c|--config)	configdir="$2";	shift;;
			-m|--min)	min_size="$2";	shift;;
			-p|--partition)	add_part "$2";	shift; let part+=1;;
			-t|--title)	EFIname="$2";	shift;;
			-o|--overlay)	overlay="$2";	shift;;
			-d|--device)	device="$2";	shift;;
			-s|--sync)	mount_opts="-o sync";;
			--nvdefault)	nvdefault=true;;
			--msoft)	msoft=true;;
			-h|--help)	usage 255;;
			*) device="$1";;
		esac
		shift
	done
	let number_of_parts=$part-1
}

get_dirs()
{
	for knownloc in /usr/share/syslinux /usr/lib/syslinux; do
		if [ -e $knownloc/bios/ifcpu64.c32 ]; then
			biosdir=$knownloc/bios
		elif [ -e $knownloc/ifcpu64.c32 ]; then
			biosdir=$knownloc
		fi
		if [ -e $knownloc/efi64/ifcpu64.c32 ]; then
			efi64dir=$knownloc/efi64
		fi
		if [ -e $knownloc/efi32/ifcpu64.c32 ]; then
			efi32dir=$knownloc/efi32
		fi
	done
	if [ -z "$configdir" ] || [ ! -e $configdir/syslinux.cfg ]; then
		usage 14 "You must specify and syslinux theme dir with a syslinux.cfg inside."
	fi
	if [ -z "$biosdir" ] || [ -z "$efi64dir" ] || [ -z "$efi32dir" ]; then
		usage 11 "We could not get a good read on your syslinux install."
	fi
	if [ -n "$overlay" ] && [ ! -e "$overlay" ]; then
		usage 15 "The requested root overlay directory $overlay, does not exist!"
	fi
	if [ ! -e `which extlinux` ]; then
		usage 12 "Could not find extlinux executable."
	fi
}

is_enabled()
{
	if [ -n "$1" ]; then
		for value in true on yes y 0; do
			if [ "$value" == "$1" ]; then
				return 0
			fi
		done
	fi
	return 1
}

scan_config()
{
	# Scan config file for potentially needed com32 files
	if [ -e $1 ]; then
		for com in \
			pmload vesamenu sdi cpuidtest dmitest whichsys vpdtest \
			elf cpuid debug linux vesainfo pxechn meminfo \
			pcitest ifplop ethersel liblua ifmemdsk kbdmap libcom32 \
			libmenu prdhcp gfxboot hexdump config libutil gpxecmd \
			kontron_wdt disk zzjson libgpl chain host rosh ifcpu \
			ifcpu64 hdt menu lua mboot cmd; do

			grep $1 -oe $com.c32 >> /tmp/syslinux-com32
		done
	else
		usage 13 "Could not find config $config."
	fi
}

com_deps()
{
	for lib in libutil libcom32 liblua libgpl libmenu; do
		if ! grep -qe $lib.c32 /tmp/syslinux-com32; then
			for module in `eval echo "\$"$lib`; do
				if grep -qe $module.c32 /tmp/syslinux-com32; then
					echo "$lib.c32" >> /tmp/syslinux-com32
					if [ "$lib" == "libmenu" ]; then
						echo libutil.c32 >> /tmp/syslinux-com32
						echo libcom32.c32 >> /tmp/syslinux-com32
					fi
				fi
			done
		fi
	done
	cat /tmp/syslinux-com32 |sort -u > /tmp/sorted
	rm /tmp/syslinux-com32
	mv /tmp/sorted /tmp/syslinux-com32
}

copy_files()
{
	ESP=/tmp/syslinux-mount
	BIOSDIR=$ESP/boot/syslinux
	EFI32=$ESP/EFI/"$EFIname"/efi32
	EFI64=$ESP/EFI/"$EFIname"/efi64
	MSDIR=$ESP/EFI/Microsoft/Boot
	NVDIR=$ESP/EFI/BOOT
	mkdir -p "$BIOSDIR"
	mkdir -p "$EFI32"
	mkdir -p "$EFI64"
	echo -e "\nCopying Syslinux Theme"
	copy_dir "$configdir"		"$BIOSDIR"
	copy_dir "$configdir"		"$EFI32"
	copy_dir "$configdir"		"$EFI64"
	if is_enabled $nvdefault; then
		copy_dir "$configdir"	"$NVDIR"
	fi
	if is_enabled $msoft; then
		copy_dir "$configdir" 	"$MSDIR"
	fi
	for com in `cat /tmp/syslinux-com32`; do
		echo -e "\nCopying com32 files"
		copy_file "$biosdir/$com"	"$BIOSDIR/$com"
		copy_file "$efi32dir/$com"	"$EFI32/$com"
		copy_file "$efi64dir/$com"	"$EFI64/$com"
		if is_enabled $nvdefault; then
			copy_file "$efi64dir/$com" "$NVDIR/$com"
		fi
		if is_enabled $msoft; then
			copy_file "$efi64dir/$com" "$MSDIR/$com"
		fi
	done
	echo -e "\nCopying EFI loaders"
	copy_file "$efi32dir/syslinux.efi"	"$EFI32/syslinux.efi"
	copy_file "$efi32dir/ldlinux.e32" 	"$EFI32/ldlinux.e32"
	copy_file "$efi64dir/syslinux.efi"	"$EFI64/syslinux.efi"
	copy_file "$efi64dir/ldlinux.e64"	"$EFI64/ldlinux.e64"
	if is_enabled $nvdefault; then
		copy_file "$efi64dir/syslinux.efi" "$NVDIR/bootx64.efi"
		copy_file "$efi64dir/ldlinux.e64"  "$NVDIR/ldlinux.e64"
	fi
	if is_enabled $msoft; then
		copy_file "$efi64dir/syslinux.efi" "$MSDIR/bootmgfw.efi"
		copy_file "$efi64dir/ldlinux.e64"  "$MSDIR/ldlinux.e64"
	fi
	echo -e "\nCopying in the Overlay Directory"
	if [ -n "$overlay" ]; then
		copy_dir "$overlay"	"$ESP"
	fi
}

efi_ready()
{
	if [ -z "$EFIname" ]; then
		usage 9 "You must specify the name of 'Your' EFI bootloader."
	fi
	if [ -z "$ESPpart" ]; then
		usage 10 "You must have at least one ESP partition."
	fi
	return 0
}

block_device()
{
	if [ -n "$1" ] && \
	   [ -e /sys/block/`basename "$1"`/dev ]; then
		return 0
	else
		usage 1 "No block device specified, or not a block device."
	fi
}

not_being_used()
{
	for mount in `list_mounts "$1"`; do
		if [ -n "`fuser -m $mount`" ]; then
			usage 2 "Device $1 is still in use."
		fi
	done
	return 0
}

user_agrees()
{
	while [ -z "$REPLY" ]; do
		echo "All data on the selected device is about to be overwritten!"
		echo "Are you sure you want to do this?"
		read -n 1 -r
		if   [[ "$REPLY" =~ ^[Yy]$ ]]; then
			echo ""
			return 0
		elif [[ "$REPLY" =~ ^[Nn]$ ]]; then
			exit 3
		else
			echo -e "\nInvalid response. $REPLY\n"
			unset REPLY
		fi
	done
}

add_part()
{
	oIFS=$IFS
	IFS='\n'
	let ID[$part]=$part+1 
	if [ "${ID[$part]}" == "128" ]; then
		echo "Really, you need that many partitions?"
		exit 5150
	fi
	# linux home swap data ESP
	type[$part]=`echo "$1" |cut -d':' -f1`
	if echo $1 | grep -qe ":"; then
		size[$part]=`echo "$1" |cut -d':' -f2`
		label[$part]=`echo "$1" |cut -d':' -f3`
	fi
	if [ -z "${size[$part]}" ]; then
		size[$part]=0
	fi
	case ${type[$part]} in
		l|linux) type[$part]=8300;;
		s|swap)	type[$part]=8200;;
		h|home) type[$part]=8302;;
		d|data) type[$part]=0700;;
		LVM)	type[$part]=8e00;;
		ESP)	type[$part]=ef00
			if [ -n "$ESPpart" ]; then
				usage 12 "You can only have one ESP partition."
			else
				ESPpart=${ID[$part]}
			fi
		;;
	esac
	IFS=$oIFS
}

convert_to_sectors()
{
	local size
	local unit
	unit="`echo $1 |sed -e s/[0-9]//g`"
	if [ -n "$unit" ]; then
		unit=`echo $unit |tr [a-z] [A-Z]`
		value=${1%?}
	else
		unit=B
		value=$1
	fi
	case $unit in
		B)	let "size=${value}/512";;
		S)	let "size=${value}";;
		K)	let "size=${value}*2";;
		M)	let "size=${value}*2*1024";;
		G)	let "size=${value}*2*1024*1024";;
		*)	echo "Invalid Unit $unit"; usage 5;;
	esac
	echo $size
}

enough_room()
{
	disk_size=`blockdev --getsz $device`
	let last_psec=$disk_size-32
	let last_psec=$last_psec/2048*2048
	let last_psec-=1
	if [ -n "$min_size" ]; then
		min_size=`convert_to_sectors $min_size`
		if [ "$last_psec" -lt "$min_size" ]; then
			usage 7 "Disk is less than the requested size!"
		fi
	fi
	total=2048
	for part in `seq 0 $number_of_parts`; do
		if [ "$total" == "$last_psec" ]; then
			usage 8 "Only one partition can be expanded to fill the disk, and it must be the last one."
		fi
		start[$part]=$total
		if [ -n "${size[$part]}" ] && [ "${size[$part]}" != "0" ]; then
			size[$part]=`convert_to_sectors ${size[$part]}`
			let end[$part]=${start[$part]}+${size[$part]}-1
			let total+=${size[$part]}
		else
			end[$part]=$last_psec
			total=$last_psec
		fi
	done
	if [ "$total" -le "$last_psec" ]; then
		return 0
	else
		usage 6 "There is not enough room on the disk for all the requested partitions!"
	fi
}

install_mbr()
{
	echo -e "Installing Bootsector"
	dd if=$biosdir/gptmbr.bin of=$device bs=440 count=1 conv=notrunc
}

part_id()
{
	short_dev=`basename $device`
	if grep -qoe "$short_dev[p][0-9]*" /proc/partitions; then
		p=p
	fi
}

mount_dev()
{
	mount ${mount_opts} ${device}${p}${ESPpart} /tmp/syslinux-mount
}

main()
{
	efi_ready
	get_dirs
	# Any text file is a potential config, and there are plenty of ways to get one in there,
	# so lets look at all of them in the config folder.
	for file in `find $configdir -type f`;do 
		if file $file |grep -qe 'ASCII text'; then
			scan_config $file
		fi
	done
	com_deps
	if block_device $device && \
	   not_being_used $device && \
	   enough_room $device && \
	   user_agrees; then
		partition
		format
		install_mbr
		mkdir -p /tmp/syslinux-mount
		mount_dev
		sync
		copy_files
		_sync
		echo -e "\nInstalling Bios Bootloader"
		extlinux -i $BIOSDIR
		sync
		umount /tmp/syslinux-mount
		rmdir /tmp/syslinux-mount
		rm  /tmp/syslinux-com32
	fi
}

buffer_size()
{
	local dirty=`grep -e Dirty: /proc/meminfo |grep -oe "[0-9]*"`
	local writeback=`grep -e Writeback: /proc/meminfo |grep -oe "[0-9]*"`
	let buffer=$dirty+$writeback
	echo $buffer
}

_sync()
{
	echo -e "\nSyncronizing the disk"
	freq=2
	let max=`buffer_size`
	last=$max
	sync &
	while pidof sync 2>&1>/dev/null; do
		now=`buffer_size`
		let persec=$last-$now
		let persec=$persec/$freq
		let progress=$max-$now
		let pct=100*$progress/$max
		printf "Progress %3s at %6s Per Second\r"  "${pct}%"  "${persec}K"
		last=$now
		sleep $freq
	done
	echo ""
}

list_mounts()
{
	grep -oe "$1[0-9]*" /proc/mounts
}

partition()
{
	part_id
	for mount in `list_mounts ${device}${p}`; do
		umount -f $mount
	done
	dd if=/dev/zero of=$device bs=1M count=2
	dd if=/dev/zero of=$device bs=512 count=32 seek=$(($disk_size - 32))
	blockdev --rereadpt $device
	sgdisk -o $device
	echo -e "\nCreating Partitions"
	printf "%3s %4s %12s %-40s\n" ID Type Size Label
	echo "==================================================="
	for part in `seq 0 $number_of_parts`; do
		printf "%3s %4s %12s %-40s\n" "${ID[$part]}" "${type[$part]}" "${size[$part]}" "${label[$part]}"
		if [ -n "${label[$part]}" ]; then
			sgdisk	-n ${ID[$part]}:${start[$part]}:${end[$part]} \
					-t ${ID[$part]}:${type[$part]} \
					-c ${ID[$part]}:"${label[$part]}" \
					$device 1> /dev/null
		else
			sgdisk	-n ${ID[$part]}:${start[$part]}:${end[$part]} \
					-t ${ID[$part]}:${type[$part]} \
					$device 1> /dev/null
		fi
	done
	sgdisk $device --attributes=1:set:2 1> /dev/null
}

format()
{
	part_id
	echo -e "\nFormating Partitions"
	for part in `seq 0 $number_of_parts`; do
		case ${type[$part]} in
			0700|ef00)
				if [ -n "${label[$part]}" ]; then
					mkfs.vfat ${device}${p}${ID[$part]} -n "${label[$part]}"
				else
					mkfs.vfat ${device}${p}${ID[$part]}
				fi
			;;
			8300|8302)
				if [ -n "${label[$part]}" ]; then
					mkfs.ext4 ${device}${p}${ID[$part]} -L "${label[$part]}"
				else
					mkfs.ext4 ${device}${p}${ID[$part]}
				fi
			;;
			8200)
				if [ -n "${label[$part]}" ]; then
					mkswap ${device}${p}${ID[$part]} -L "${label[$part]}"
				else
					mkswap ${device}${p}${ID[$part]}
				fi
			;;
			8e00) pvcreate ${device}${p}${ID[$part]}
			;;
		esac
	done
}

copy_dir()
{
	dir=$1
	if [ "`echo $dir | rev | cut -c1`" == "/" ]; then
		dir="`echo $dir| rev | cut -c2- | rev`"
	fi
	for adir in `find "$dir" -type d | sed -e s:^"$dir"::g |cut -c2-`; do
		mkdir -p "$2/$adir"
	done
	for file in `find "$dir" -type f| sed -e s:^"$dir"/::g`; do
		copy_file "$dir/$file" "$2/$file"
	done
}

copy_file()
{
	cp -f "$1" "$2" &

	orig_size=`stat -c %s "$1"`
	dest_size=0
	if [ "$orig_size" -gt "512000" ]; then
		while [ $orig_size -gt $dest_size ]; do
			if [ -e "$2" ]; then
				dest_size=`stat -c %s "$2"`
			fi
			let pct=100*$dest_size/$orig_size
			printf "Copying %-15s to %-50s %-3s Complete\r" "`basename $1`" "`dirname $2`" "${pct}%"
			sleep .1
		done
		echo ""
	else
		wait
	fi
}

getopts "$@"
main

exit 0
